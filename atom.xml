<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yuqiusuo.github.io</id>
    <title>北落师门</title>
    <updated>2020-12-02T14:00:48.626Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yuqiusuo.github.io"/>
    <link rel="self" href="https://yuqiusuo.github.io/atom.xml"/>
    <subtitle>路漫漫其修远兮，武将上下而求索</subtitle>
    <logo>https://yuqiusuo.github.io/images/avatar.png</logo>
    <icon>https://yuqiusuo.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 北落师门</rights>
    <entry>
        <title type="html"><![CDATA[3. 设计模式之原则]]></title>
        <id>https://yuqiusuo.github.io/post/20201202/</id>
        <link href="https://yuqiusuo.github.io/post/20201202/">
        </link>
        <updated>2020-12-02T13:58:49.000Z</updated>
        <content type="html"><![CDATA[<p>在最先接触设计模式的时候，我就看到了对「开闭原则」的介绍，后续又陆陆续续接触了「单一职责原则」、「迪米特法则」等等，今天在这里对设计模式的各原则进行一个统一的记录。</p>
<ul>
<li>单一职责原则</li>
<li>开放-封闭原则</li>
<li>里式代换原则</li>
<li>依赖倒转原则</li>
<li>迪米特法则</li>
<li>接口隔离原则</li>
</ul>
<h4 id="单一职责原则">单一职责原则</h4>
<blockquote>
<p>单一职责原则（SRP），就一个类而言，应该仅有一个引起它变化的原因。</p>
</blockquote>
<p>这个原则说的就是<strong>一个类只关注一件事情</strong>，我们经常会看到这个原则，比如我们开始学习编程的时候，会说到怎么优化代码，其中一项就是一个函数只做一件事情这样的，那时候「只做一件事情」就在我脑海中留下了比较深刻的印象。</p>
<p>现在随着前端组件化的发展，我们将页面也细分为大大小小的组件来进行拼接。在这个时候，「单一职责原则」就和前端的工作息息相关了，我们在拆分组件的时候，也应该保证<strong>每一个组件只做一件事情</strong>，只关注一个重点。这样我们的页面在后期的扩展维护上就会节省很多的功夫，这也是优秀的组件应该做到的。</p>
<p>「单一职责原则」的有点也是显而易见的：</p>
<ul>
<li>代码复杂度变低</li>
<li>可维护性提高</li>
<li>需求变更引起的影响减小</li>
</ul>
<h4 id="开放-封闭原则">开放-封闭原则</h4>
<blockquote>
<p>开放-封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。[ASD]</p>
</blockquote>
<p>我们在开发系统的时候，经常会有这样的感受，在产品最开始设计的时候，我们就尽可能把准备工作多做一些，希望最开始的框架能够满足未来的一些需求。但是随着开发工作的逐渐深入，我们最头疼的情况就发生了：不管我们开始的时候想的有多么完善，都无法满足未来的需求，总是需要去扩展我们的框架。这种时候，「开放-封闭原则」就是我们的指导。</p>
<p>其实我们需要面对的问题就是：但原框架无法适应新需求的时候，我们是修改原来的代码，还是扩展原来的代码？我们经常会发现一个需求只要修改一小段代码就可以完成，然后我们就用了很快的时间完成了任务，之后却发现引起了许多的问题。所以我们在处理新需求的时候，应该更多地在源代码的基础之上去加东西，而不要去改动原有的代码，以防止影响原来的功能。</p>
<p>「开放封闭原则」的特征就是：</p>
<ul>
<li>对于扩展是开放的</li>
<li>对于更改是封闭的</li>
</ul>
<p>它的优点也显而易见：</p>
<ul>
<li>提高了系统的稳定性</li>
</ul>
<blockquote>
<p>开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、复用性好、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。</p>
</blockquote>
<h4 id="里式代换原则">里式代换原则</h4>
<blockquote>
<p>里氏代换原则：子类型必须能够替换掉他们的父类型。</p>
</blockquote>
<p>我的理解是「里式代换原则」保留了父类的可扩展性，即我们设计的时候在父类的基础上添加特性，在具体实现的时候利用子类来实现。好处就是：</p>
<ul>
<li>可以随时随地地扩展父类，因为父类的扩展不影响具体功能</li>
<li>所有具体功能的实现都由子类去做，系统是感知不到父类的存在的</li>
<li>父类可以真正的被复用</li>
</ul>
<h4 id="依赖倒转原则">依赖倒转原则</h4>
<blockquote>
<p>依赖倒转原则</p>
<p>A. 高层模块不应该依赖低层模块。两个都应该依赖抽象。</p>
<p>B. 抽象不应该依赖细节。细节应该依赖抽象。</p>
</blockquote>
<p>说的清楚一些应该就是我们要「针对接口编程，而不是针对实现编程」。</p>
<p>假如当下我们要做一个关于考试分数的柱状图标，首先我们就会想到用echarts来做这个图表。</p>
<pre><code class="language-javascript">// echarts类
class Echarts {
    constructor() {}

    // 绘制柱状图
    renderBar(options) {}

    // 绘制折线图图
    renderLine(options) {}

    // 绘制饼图
    renderPie(options) {}
}

// 绘制图表类
class Render {
    tool = new Echarts();
    constructor() {}

    // 绘制柱状图
    renderBar(options) {
        this.tool.renderBar(options);
    }

    // 绘制折线图图
    renderLine(options) {
        this.tool.renderLine(options);
    }

    // 绘制饼图
    renderPie(options) {
        this.tool.renderLine(options);
    }
}

const render = new Render();
render.renderBar();
render.renderLine();
render.renderLine();
</code></pre>
<p>但是这时客户觉得更喜欢阿里的G2图表，这时我们修改代码就发现很难去修改，因为我们的业务绘制代码直接依赖了Echarts，如果我们需要改图表依赖，我们就要改很多东西，那怎么做才好一些呢？</p>
<pre><code class="language-javascript">// 依赖倒置原则
// echarts类
class Echarts {
    constructor() {}

    // 绘制柱状图
    renderBar(options) {}

    // 绘制折线图图
    renderLine(options) {}

    // 绘制饼图
    renderPie(options) {}
}

// g2
class G2 {
    constructor() {}

    // 绘制柱状图
    renderBar(options) {}

    // 绘制折线图图
    renderLine(options) {}

    // 绘制饼图
    renderPie(options) {}
}

function getTool(type) {
    switch (type) {
        case 'echarts':
            return new Echarts();
            break;
        case 'g2':
            return new G2();
            break;
    }
}

// 绘制图表类
class Render {
    constructor(tool) {
        this.tool = tool;
    }

    // 绘制柱状图
    renderBar(options) {
        this.tool.renderBar(options);
    }

    // 绘制折线图图
    renderLine(options) {
        this.tool.renderLine(options);
    }

    // 绘制饼图
    renderPie(options) {
        this.tool.renderLine(options);
    }
}

const render = new Render(getTool('g2'));
render.renderBar();
render.renderLine();
render.renderLine();
</code></pre>
<p>由上可见，我们新增了一个<code>getTool</code>的方法，如果我们需要调整或者扩展图表类，我们只需要扩展底层方法即可，代价和难度都会大大降低，也减少了高层代码（绘制图表类）对底层代码（图表类）的依赖。</p>
<h4 id="迪米特法则">迪米特法则</h4>
<blockquote>
<p>迪米特法则（LoD）：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p>
</blockquote>
<p>举个例子，现在我们打车都用上了高德地图，但是还是有些地方地图定位的不是特别准确，这些时候就需要我们口头告诉司机应该怎么走。这种场景下我们就有了3个类：<strong>乘客</strong>、<strong>司机</strong>和<strong>汽车</strong>，其实我们最终的目的是希望指挥车子的运动（向左转、向右转等等），但是其实我们和车子的控制没有关系，我们就需要通过第三者（<strong>司机</strong>）来达成目的。</p>
<pre><code class="language-javascript">// 迪米特法则
class Car {
    constructor() {}

    // 左转
    turnLeft() {}

    // 右转
    turnRight() {}

    // 掉头
    turnRound() {}

    // 直行
    goStraight() {}
}

class Driver {
    constructor(car) {
        this.car = car;
    }

    // 左转
    turnLeft() {
        this.car.turnLeft();
    }

    // 右转
    turnRight() {
        this.car.turnRight();
    }

    // 掉头
    turnRound() {
        this.car.turnRound();
    }

    // 直行
    goStraight() {
        this.car.goStraight();
    }
}

class Customer {
    constructor() {}

    inform(driver, direction) {
        switch (direction) {
            case 'left':
                driver.turnLeft();
                break;
            case 'right':
                driver.turnRight();
                break;
            case 'round':
                driver.turnRound();
                break;
            case 'straight':
                driver.goStraight();
                break;
        }
    }
}

const car = new Car();
const driver = new Driver(car);
const customer = new Customer();

// 乘客告诉司机下个路口左转
customer.inform(driver, 'left');
// 乘客告诉司机下个路口右转
customer.inform(driver, 'right');
</code></pre>
<blockquote>
<ol>
<li>在类的结构设计上，每一个类都应当尽量降低成员的访问权限；</li>
<li>迪米特法则其根本思想，是强调了类之间的松耦合；</li>
<li>类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。</li>
</ol>
</blockquote>
<h4 id="接口隔离原则">接口隔离原则</h4>
<blockquote>
<p>一个类对另一个类的依赖应该建立在最小的接口上。</p>
</blockquote>
<p>对于这个原则，我的理解是这样的：在当下我们写页面的时候，常用的UI框架有ElementUI和Ant Design UI，在这两个UI框架中，有三个组件：<code>Input</code>、<code>AutoComplete</code>和<code>InputNumber</code>，我们会发现他们有很多共同的地方：</p>
<ul>
<li>都是输入框</li>
<li>支持相同的事件（Focus、Blur等等）</li>
<li>支持相同的属性（readOnly，autofocus等等）</li>
</ul>
<p>除此之外他们也都有自己的特性：</p>
<ul>
<li><code>AutoComplete</code>支持自动搜索</li>
<li><code>InputNumber</code>对数字有特殊的处理</li>
</ul>
<p>其实我们能不能把这些特性全部集中在<code>Input</code>上呢？其实应该也是可以的，那样的话<code>Input</code>组件就会很臃肿，也提供了很多我们平时用不到的特性。</p>
<p>那最好的方式就是将「自动搜索」和「数字特殊处理」当做独立接口处理，以形成我们今天的3个组件，让我们在需要的地方用最适合的组件。</p>
<p>我想这是前端工程师对「接口隔离原则」的一个很棒的应用。</p>
<hr>
<h6 id="参考">参考</h6>
<p>大话设计模式 -- 程杰<br>
<a href="https://element.eleme.cn/#/zh-CN">Element-UI</a><br>
<a href="https://ant.design/index-cn">Ant Design</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2. 设计模式之策略模式]]></title>
        <id>https://yuqiusuo.github.io/post/20201130/</id>
        <link href="https://yuqiusuo.github.io/post/20201130/">
        </link>
        <updated>2020-11-30T14:18:30.000Z</updated>
        <content type="html"><![CDATA[<h4 id="一-定义">一、定义</h4>
<p>今天我们讨论的设计模式是「策略模式」，策略模式比较好理解，首先我们看一下他的定义：</p>
<blockquote>
<p>策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，他可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合「DEP」。</p>
</blockquote>
<p>由上面的定义我们可以看到，策略模式有3个要素：</p>
<ul>
<li>策略模板：策略模式的算法都是为了完成相同的工作的，只是可能触发条件不同，所以我们就可以抽象出来一个策略模板，类似于「工厂模式中的产品模板」；</li>
<li>策略：根据具体场景实现不同的策略，以根据实际场景得到具体的结果；</li>
<li>上下文：上下文根据场景不同来决定使用哪种策略。</li>
</ul>
<h4 id="二-举例说明">二、举例说明</h4>
<p>策略模式在生活中也比较常见，下面举例说明：</p>
<p>当我们在生活中乘坐公交地铁的时候，合肥市的票价是2元、学生半价、老年人免票，这就是一种常见的设计模式，我们可以看出：</p>
<ul>
<li>都是为了解决人们乘车计价的问题</li>
<li>不同年龄段的人计算价格方法不同</li>
</ul>
<p>那我们就有实现方案：</p>
<pre><code class="language-javascript">//策略模板
class StrategyTemplate {
    constructor() {}
}

// 老年人免票
class OldPersonStrategy extends StrategyTemplate {
    constructor() {}

    calculatePrice() {
        return 0;
    }
}

// 学生半价
class StudentStrategy extends StrategyTemplate {
    constructor() {}

    calculatePrice() {
        return 1;
    }
}

// 普票2元
class NormalStrategy extends StrategyTemplate {
    constructor() {}

    calculatePrice() {
        return 2;
    }
}

// 上下文传入策略并使用
class BusContext {
    constructor(strategy) {
        this.strategy = strategy;
    }

    pay() {
        return this.strategy.calculatePrice();
    }
}

// 使用
const oldPerson = new BusContext(new OldPersonStrategy());
oldPerson.pay();
const student = new BusContext(new StudentStrategy());
student.pay();
const person = new BusContext(new NormalStrategy());
person.pay();
</code></pre>
<p>生活中我们随处可见也有很多策略模式的使用，比如洗衣机（快洗、漂洗、大件等）、电饭煲（煮饭、煮粥等）、电动牙刷（高频、中频、低频）、购物（满减、打折、返利等）。</p>
<h4 id="总结">总结</h4>
<p>由上面这么多的例子我们可以总结出来，策略模式的使用场景有几个特点：</p>
<ul>
<li>面对一个问题/需求有多种解决策略，需要判断不同的场景</li>
<li>场景的数量较少</li>
</ul>
<p>优点就是：</p>
<ul>
<li>策略与策略之间相互独立，扩展性、维护性比较好</li>
<li>单元测试好做</li>
<li>减少了<code>switch/if else</code>判断</li>
</ul>
<p>缺点就是：</p>
<ul>
<li>不适合解决场景太多的情况</li>
</ul>
<hr>
<h6 id="参考">参考</h6>
<ul>
<li>
<p>[大话设计模式 - 程杰]:</p>
</li>
<li>
<p><a href="https://www.bilibili.com/video/BV1vT4y1E7g6?from=search&amp;seid=4459298229967337994">五分钟学设计模式.10.策略模式</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1. 设计模式之工厂模式]]></title>
        <id>https://yuqiusuo.github.io/post/20201121/</id>
        <link href="https://yuqiusuo.github.io/post/20201121/">
        </link>
        <updated>2020-11-19T14:52:39.000Z</updated>
        <content type="html"><![CDATA[<h4 id="一-介绍">一、介绍</h4>
<p>每当我听到有人讨论设计模式时，我听到最多的概念好像就是「工厂模式」，他就像是背单词时候的「abandon」，它易于理解且经常用到，所以我也将它作为学习「设计模式」的第一步。</p>
<p>我们都知道，工厂模式是为了<strong>创建对象</strong>而存在的（主要是听到的太多了~）。对象是一个系统的基石，我们编写的功能都可以抽象成由一个个对象组合而成，请求是由一个个XmlHttpRequest对象执行的、页面由一个个DOM节点对象堆砌而成等等。我们在前端框架之中往往会对请求作一层层的封装（比如我们会在JQuery.ajax、axios之上再封装一层），那我们在生成这些对象的时候，会发现他们都有着相似之处，就像是由工厂生产出来的一个个产品，那我们封装的过程其实就和「工厂模式」很相近了。</p>
<p>工厂模式属于**「创建型模式」**的一种，与之相关的有：简单工厂模式、工厂模式和抽象工厂模式。</p>
<h4 id="二-简单工厂模式">二、简单工厂模式</h4>
<p>简单工厂模式可以理解为「一家工厂根据不同的模具来生产产品」的模式，如下举例：</p>
<pre><code class="language-javascript">// 工厂
class SimpleRequestFactory {
    constructor() {}

    createRequest(type) {
        let req = null;
        switch (type) {
            case 'get':
                req = new GetRequest(); // GetRequest为get请求的模具
                break;
            case 'post':
                req = new PostRequest(); // PostRequest为post请求的模具
                break;
        }

        return req;
    }
}

// 工厂生产处get请求的产品
const getRequestInstance = SimpleRequestFactory.createRequest('get');
getRequestInstance.setUrl('https://xxx'); // 设置get请求的url
getRequestInstance.setParams({id: 'xxx'}); // 设置get请求的参数
getRequestInstance.request();

// 工厂生产处post请求的产品
const postRequestInstance = SimpleRequestFactory.createRequest('post');
postRequestInstance.setUrl('https://xxx'); // 设置post请求的url
postRequestInstance.setParams({id: 'xxx'}); // 设置post请求的参数
getRequestInstance.request();
</code></pre>
<p>以上就是简单工厂模式运行模式，利用这种方式，我们就可以根据不同请求的需要，来不断生产request请求对象，我们并不需要关心request的实例对象是怎么生成的，我们只需要得到它、使用它即可。</p>
<p>所以「简单工厂模式」的特点就是：</p>
<ul>
<li>我们只需要知道我们要生产的产品的名称即可</li>
<li>我们不需要知道产品怎么来的，我们只需要知道产品怎么用</li>
</ul>
<p>由上面的代码我们也能看出，简单工厂模式是具有三大要素的：</p>
<ul>
<li>工厂类：由它根据模具来生产产品</li>
<li>模具类（抽象类产品）：它是所有产品的基石，我们根据它们来得到用户使用的产品</li>
<li>产品对象：简单工厂模式的创建目标，用户最终使用的就是具体的产品对象</li>
</ul>
<h4 id="三-工厂模式">三、工厂模式</h4>
<p>工厂模式是在简单工厂模式之上做了优化处理之后形成一种模式，我们先看有关于工厂模式的代码</p>
<pre><code class="language-javascript">class RequestFactory {
    constructor() {}

    createRequest() {
        // 我只代表每种RequestFactory都要实现createRequest方法
        // 而我不生产任何产品
    }
}

// get请求的工厂
class GetRequestFactory extends RequestFactory {
    constructor() {}

    createRequest() {
        return new GetRequest();
    }
}

// post请求的工厂
class PostRequestFactory extends RequestFactory {
    constructor() {}

    createRequest() {
        return new PostRequest();
    }
}

// put请求的工厂
class PutRequestFactory extends RequestFactory {
    constructor() {}

    createRequest() {
        return new PutRequest();
    }
}

// 生产get请求的产品
const getRequestIns = GetRequestFactory.createRequest();
getRequestIns.setUrl('https://xxx'); // 设置get请求的url
getRequestIns.setParams({id: 'xxx'}); // 设置get请求的参数
getRequestIns.request();

// 生产post请求的产品
const postRequestIns = PostRequestFactory.createRequest();
postRequestIns.setUrl('https://xxx'); // 设置get请求的url
postRequestIns.setParams({id: 'xxx'}); // 设置get请求的参数
postRequestIns.request();

// 生产put请求的产品
const putRequestIns = PutRequestFactory.createRequest();
putRequestIns.setUrl('https://xxx'); // 设置get请求的url
putRequestIns.setParams({id: 'xxx'}); // 设置get请求的参数
putRequestIns.request();
</code></pre>
<p>由上面的代码可以看出，我们把每一种请求的生产工厂都独立出来了，看似没有简单工厂模式方便，但是我们可以在生活之中找到例子辅助理解。</p>
<p>比如我们A公司是一家生产饮品的公司，我们最开始有一条生产线专门生产矿泉水，我们叫「XX山泉」，后来我们发现矿泉水做的不错，我们想多做一些产品，如「XX AD钙奶」和「XX 纯牛奶」，那我们应该怎么做呢？这时我们可能根据生活中看到的例子，可以想到，我们只要照搬A公司的基础部门（如行政），再成立几家公司，分别生产「XX AD钙奶」和「XX 纯牛奶」即可。那我们为什么不在A公司的基础上不断扩充生产线呢？因为一旦生产线越来越多，管理就越来越复杂，我们需要不断地折腾A公司，还不如复制一个抽象公司，然后专事专做。</p>
<p>上面的例子就是为了帮助我们理解「简单工厂模式」和「工厂模式」的区别的，那我们什么时候用哪种模式呢？我的理解就是：</p>
<ul>
<li>如果系统简单，需要生成的对象类型可数，就用「简单工厂模式」</li>
<li>如果系统存在扩展的可能性，且我们无法预计未来扩展的规模，就用「工厂模式」</li>
</ul>
<p>其实上面说的也关乎到设计模式中的一个原则——<strong>「开闭原则」</strong>。</p>
<p>再回到「工厂模式」之上，我们可以看到工厂模式的特点就是：</p>
<ul>
<li>符合「开闭原则」，易于扩展</li>
<li>会增加系统的复杂度</li>
</ul>
<p>「工厂模式」包含四大要素：</p>
<ul>
<li>抽象工厂：抽象工厂不是一家实际的公司，但是他拥有所有公司共同点</li>
<li>实体工厂：实体工厂负责生产具体的产品</li>
<li>模具（抽象产品）：我们根据模具来生产产品</li>
<li>实体产品：用户最终得到并使用实体产品</li>
</ul>
<h4 id="三-抽象工厂模式">三、抽象工厂模式</h4>
<p>此时肯定有朋友想到了一个问题：「现实中我们也并不是所有的工厂都只生产一类产品，牛奶工厂可以生产纯牛奶、酸奶等等」，这就是我们提到的抽象工厂模式了。示例代码如下</p>
<pre><code class="language-javascript">// 抽象工厂
class RequestFactory {
    constructor() {}

    createRequest() {
        // 我只代表每种RequestFactory都要实现createRequest方法
        // 而我不生产任何产品
    }
}

/** 看这 start **/
// 抽象的get请求
class GetRequest{
    constructor() {}

    request() {}
}

// 简单的get请求（不需要带参数的get请求）
class SimpleGetRequest extends GetRequest{
    constructor() {}

    request() {}
}

// 普通的get请求
class NormalGetRequest extends GetRequest{
    constructor() {}

    request() {}
}

// 抽象的post请求
class PostRequest{
    constructor() {}

    request() {}
}

// 简单的post请求（不需要带参数的post请求）
class SimplePostRequest{
    constructor() {}

    request() {}
}

// 普通的post请求
class NormalPostRequest extends PostRequest{
    constructor() {}

    request() {}
}
/** 看这 end **/

// get请求的工厂
class GetRequestFactory extends RequestFactory {
    constructor() {}

    createSimpleRequest() {
        return new SimpleGetRequest();
    }

    createNormalRequest() {
        return new NormalGetRequest();
    }
}

// post请求的工厂
class PostRequestFactory extends RequestFactory {
    constructor() {}

    createSimpleRequest() {
        return new SimplePostRequest();
    }

    createNormalRequest() {
        return new NormalPostRequest();
    }
}

// 生产get请求的产品
const simpleGetRequestIns = GetRequestFactory.createSimpleRequest();
simpleGetRequestIns.setUrl('https://xxx'); // 设置get请求的url
simpleGetRequestIns.setParams({id: 'xxx'}); // 设置get请求的参数
simpleGetRequestIns.request();
const normalGetRequestIns = GetRequestFactory.createNormalRequest();
normalGetRequestIns.setUrl('https://xxx'); // 设置get请求的url
normalGetRequestIns.setParams({id: 'xxx'}); // 设置get请求的参数
normalGetRequestIns.request();

// 生产post请求的产品
const simplePostRequestIns = PostRequestFactory.createSimpleRequest();
simplePostRequestIns.setUrl('https://xxx'); // 设置get请求的url
simplePostRequestIns.setParams({id: 'xxx'}); // 设置get请求的参数
simplePostRequestIns.request();
const normalPostRequestIns = PostRequestFactory.createNormalRequest();
normalPostRequestIns.setUrl('https://xxx'); // 设置get请求的url
normalPostRequestIns.setParams({id: 'xxx'}); // 设置get请求的参数
normalPostRequestIns.request();
</code></pre>
<p>通过上面的代码，我们可以看到，抽象工厂模式之于工厂模式的不同就是在工厂模式的基础上，对产品也进行了一层抽象，从而实现了一个实体工厂也能生产多个产品的功能。</p>
<p>「抽象工厂模式」的好处就是：</p>
<ul>
<li>易于交换产品系列，我们只需要初始化工厂，就可以随意切换生产的产品</li>
<li>它让具体的创建实例过程和客户端分离，客户端通过他们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。</li>
</ul>
<p>「抽象工厂模式」有五大要素：</p>
<ul>
<li>抽象工厂</li>
<li>实体工厂</li>
<li>抽象模具</li>
<li>模具</li>
<li>实体产品</li>
</ul>
<blockquote>
<p>创建型模式: 创建型模式抽象了实例化的过程，他们帮助一个系统独立于如何创建、组合和表示它的那些对象。创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。允许客户用结构和功能差别很大的「产品」对象配置一个系统。配置可以是静态的，即在编译时指定，也可以是动态的，就是运行时再指定。</p>
</blockquote>
<blockquote>
<p>开闭原则: 开放-封闭原则是说软件实体（类、模块、函数等等）应该是可以扩展、但是不可修改[ASD]。</p>
</blockquote>
<hr>
<h6 id="参考">参考</h6>
<ul>
<li>
<p>[大话设计模式 - 程杰]</p>
</li>
<li>
<p><a href="https://www.zhihu.com/question/20367734/answer/1089721250">工厂模式与抽象工厂模式的区别 - 贾不假</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[刀锋]]></title>
        <id>https://yuqiusuo.github.io/post/202009142152/</id>
        <link href="https://yuqiusuo.github.io/post/202009142152/">
        </link>
        <updated>2020-09-14T13:52:15.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>作者：毛姆</p>
</blockquote>
<p>今天把毛姆的「刀锋」读完，这本书和「月亮与六便士」都给了我同样的触感：「为什么有的人能这样生活下去呢？」。这两本书的主人公都追求着不同于普通人生的生活，他们不惧世俗的眼光，都只是过自己想过的生活。</p>
<p>但是我觉得「刀锋」相对于「月亮与六便士」而言要相对温和些。拉里作为一个「战争英雄」的角色进入到读者的眼中，他本拥有着「不错的」未来，但是他却执意放弃原本的生命节奏，取消订婚，不断地读书、体验生活、拜访导师，去寻找生命的真谛，最终「散尽家财」，过上普普通通的生活，只为寻求自己生命的真谛。</p>
<p>拉里传达给我的消息现在想来其实很简单：「生命属于自己，不要随波逐流」。</p>
<p>我们时常也用这句话安慰自己，告诉自己不必去比较、不必去在意别人的看法，但是往往无法做到，我们就是无可避免去把自己周边的人作比较，就是在意A有几套房、B工资几何、C结婚生子。每个人的人生都只有一次，也许父母朋友会把各种道理摆上台前，以过来人的身份告诫我们要听从劝告，只是我们要有分别的去对待这些「道理」。</p>
<p>每个人都希望寻求自己生命的真谛，在生命的种种挫折之下，我们往往服从于生活，我们希望过上跟别人一样的生活，放弃了自己的特异性。这种放弃同样也给了我们束缚，我们要把自己跟别人摆在一起，我们会去在意别人有什么而我们没有，这样我们就感到焦虑；在意我们有什么别人没有，我们就感到优越。这种比较我有时觉得是人生而既有的东西，我们一生追求的无非就是平和而已。</p>
<p>在经历种种「焦虑症状」突发之后，我发现自己依然无法放下这些比较，因为这种躺平并不是为了寻求告解，只是为了躺平而躺平而已，很难受，很纠结，很焦虑。思考的习惯无时无刻不在提醒自己要努力一些，只有真切感到焦虑发作的时候才会告诉自己要平和，身体的习惯却只能堕落性质地躺平。一切都处在违和的状态之下，却一次次在冲突之中寻找出口。</p>
<p>我们未必能做到大彻大悟，拉里在最后也没有说一定做到顿悟，只是在平常的生活之中继续体验、继续思考、继续总结。</p>
<p>我认为生活就是为了一次一次的「体验」，我们要更多地尝试新鲜的实物、去认识新鲜的人、去看看新鲜的地方。在到达生命尽头之前，永远保持好奇心，不是为了势利地前进，而是为了与世界更多次地握手。我们未必能体会到成功者地生活，但不能体验到的生活亦不可强求。</p>
<p>越过刀锋实属不易，因而智者常言救赎之道艰辛。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flex布局]]></title>
        <id>https://yuqiusuo.github.io/post/flex/</id>
        <link href="https://yuqiusuo.github.io/post/flex/">
        </link>
        <updated>2020-09-14T09:02:07.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="http://file.yuqiusuo.top/img/20200610113312.png" alt="Flex" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS面向对象-继承]]></title>
        <id>https://yuqiusuo.github.io/post/202009141653/</id>
        <link href="https://yuqiusuo.github.io/post/202009141653/">
        </link>
        <updated>2020-09-14T08:52:30.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本篇主要是「JavaScript高级程序设计-面向对象的程序设计」一章中第三篇「继承」回顾的笔记</p>
</blockquote>
<h2 id="原型链">原型链</h2>
<ol>
<li>
<p>备注</p>
<ul>
<li>实现继承的主要方式</li>
<li>利用原型让一个引用继承类型继承另一个引用类型的属性和方法</li>
</ul>
</li>
<li>
<p>示例</p>
<pre><code class="language-javascript">function SuperType() {
  this.property = true;
}

SuperType.prototype.getSuperValue = function() {
  return this.propety;
}

function SubType() {
  this.subproperty = false;
}

SubType.prototype = new SuperType();

SubType.prototype.getSubValue = function() {
  return this.subproperty
}

</code></pre>
</li>
</ol>
<p>var instance = new SubType();<br>
alert(instance.getSuperValue()); // true</p>
<pre><code>   
   
   

## 借用构造函数

1. 基本思想

   * 在子类型构造函数内部调用超类型构造函数

2. 示例

   ```javascript
   function SuperType() {
     this.colors = ['red', 'blue', 'green']
   }
   
   function SubType() {
     // 继承SuperType
     SuperType.call(this);
   }
   
   var instance = new SubType();
   instance.colors.push('black');
   alert(instance.colors); // &quot;red, blur, green, black&quot;
</code></pre>
<h2 id="组合继承">组合继承</h2>
<ol>
<li>
<p>概念</p>
<ul>
<li>指的是将原型链和借用构造函数的技术组合到一块，发挥二者之长</li>
</ul>
</li>
<li>
<p>思路</p>
<ul>
<li>使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承</li>
</ul>
</li>
<li>
<p>示例</p>
<pre><code class="language-javascript">function SuperType(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green']
}

SuperType.prototype.sayName = function() {
  alert(this.name);
}

function SubType(name, age) {
  // 继承属性
  SuperType.call(this, name);
  
  this.age = age;
}

// 继承方法
SubType.prototype = new SuperType();
Subtype.prototype.constructor = SubType;
Subtype.prototype.sayAge = function() {
  alert(this.age);
};

var instance = new SubType('Matthew', 27);
instance.colors.push('black');
alert(instance.colors); // red, blue, green, black
instance.sayName(); // Matthew
instance.sayAge(); // 27
</code></pre>
</li>
</ol>
<h2 id="原型式继承">原型式继承</h2>
<ol>
<li>
<p>备注</p>
<ul>
<li>没有严格意义上的构造函数</li>
<li>基于已有的对象创建对象，同时不必因此创建自定义类型</li>
</ul>
</li>
<li>
<p>示例</p>
<pre><code class="language-javascript">function object(o) {
  function F() {};
  F.prototype = o;
  return new F();
}

var person = {
  name: 'Matthew',
  friends: ['Wudan', 'Sanmao', 'MaP']
};

var anotherPerson = object(person);
anotherPerson.name = 'BLSM';
anotherPerson.friends.push('YQS');

alert(person.friends); // 'Wudan', 'Sanmao', 'MaP', 'YQS'
</code></pre>
</li>
</ol>
<h2 id="寄生式继承">寄生式继承</h2>
<ol>
<li>
<p>备注</p>
<ul>
<li>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象</li>
</ul>
</li>
<li>
<p>示例</p>
<pre><code class="language-javascript">function object(o) {
  function F() {};
  F.prototype = o;
  return new F();
}

function createAnother(original) {
  var clone = object(original);
  clone.sayHi = function() {
    alert('hi');
  }
  return clone;
}

var person = {
  name: 'Matthew',
  friends: ['Wudan', 'Sanmao', 'MaP']
};

var anotherPerson = createAnother(person);
anotherPerson.sayHi(); // hi
</code></pre>
</li>
</ol>
<h2 id="寄生组合式继承">寄生组合式继承</h2>
<ol>
<li>
<p>备注</p>
<ul>
<li>借用构造函数来继承属性，通过原型链的混成形式来继承方法</li>
<li>不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非是超类型原型的一个副本而已</li>
</ul>
</li>
<li>
<p>示例</p>
<pre><code class="language-javascript">function inheritPrototype(subType, superType) {
  var prototype = Object(superType.prototype);
  prototype.constructor = subType;
  subType.prototype = prototype;
}

function SuperType(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}

SuperType.prototype.sayName = function() {
  alert(this.name);
}

function SubType(name, age) {
  SuperType.call(this, name);
  this.age = age;
}

inheritPrototype(SubType, SuperType);

SubTyper.prototype.sayAge = function() {
  alert(this.age);
}
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS面向对象-创建对象]]></title>
        <id>https://yuqiusuo.github.io/post/202009141652/</id>
        <link href="https://yuqiusuo.github.io/post/202009141652/">
        </link>
        <updated>2020-09-14T08:51:49.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本篇主要是「JavaScript高级程序设计-面向对象的程序设计」一章中第二篇「创建对象」回顾的笔记</p>
</blockquote>
<h2 id="工厂模式">工厂模式</h2>
<ol>
<li>
<p>根据所接受的参数构建一个包含所有必要信息的对象。</p>
</li>
<li>
<p>示例</p>
<pre><code class="language-javascript">function createPerson(name, age, job) {
  var o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function() {
    alert(this.name);
  }
  return o;
}

var person = createPerson('Matthew', 27, 'Software Engineer');
</code></pre>
</li>
</ol>
<h2 id="构造函数模式">构造函数模式</h2>
<ol>
<li>
<p>特点：</p>
<ul>
<li>没有显式地创建对象</li>
<li>直接将属性和方法赋给this对象</li>
<li>没有return语句</li>
</ul>
</li>
<li>
<p>示例</p>
<pre><code class="language-javascript">function Person(name, age, obj) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {
    alert(this.name);
  }
}

var person = new Person('Matthew', 27, 'Software Engineer')
</code></pre>
</li>
<li>
<p>问题：</p>
<ul>
<li>每个方法都要在每个示例上重新创建一遍</li>
<li>会导致不同的作用域链和标识符解析</li>
</ul>
</li>
</ol>
<h2 id="原型模式">原型模式</h2>
<ol>
<li>
<p>好处：</p>
<ul>
<li>可以让所有对象实例共享它所包含的属性和方法</li>
</ul>
</li>
<li>
<p>示例</p>
<pre><code class="language-javascript">function Person(){}
Person.prototype.name = 'Matthew';
Person.prototype.age = 29;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
  alert(this.name);
}

var person = new Person();
person.sayName();

// 另一种
function Person(){}
Person.prototype = {
  name: 'Matthew',
  age: 27,
  job: 'Software Engineer',
  sayName: function() {
    alert(this.name);
  }
}
</code></pre>
</li>
<li>
<p>问题：</p>
<ul>
<li>不方便</li>
<li>所有的属性都是共享的，不能隐藏属性</li>
</ul>
</li>
</ol>
<h2 id="组合使用构造函数模式和原型模式">组合使用构造函数模式和原型模式</h2>
<ol>
<li>
<p>特点：</p>
<ul>
<li>最常见的方式</li>
<li>每个实例都会有自己的一份实例属性的副本，同时又共享着对方法的引用，最大限度节省内存</li>
<li>支持构造函数传递参数</li>
</ul>
</li>
<li>
<p>示例</p>
<pre><code class="language-javascript">function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
}

Person.prototype = {
  constructor: Person,
  sayName: function() {
    alert(this.name);
  }
}

var person = new Person('Matthew', 27, 'Software Engineer');
</code></pre>
</li>
</ol>
<h2 id="动态原型模式">动态原型模式</h2>
<ol>
<li>
<p>特点：</p>
<ul>
<li>把所有信息封装在构造函数中，通过在构造函数中初始化原型，又保持了同时使用构造函数和原型的有点</li>
</ul>
</li>
<li>
<p>示例</p>
<pre><code class="language-javascript">function Person(name, age, job) {
	// 属性  
  this.name = name;
  this.age = age;
  this.job = job;
  
  // 方法
  if(typeof this.sayName != 'function') {
    Person.prototype.sayName = function() {
      alert(this.name);
    }
  }
}
</code></pre>
</li>
</ol>
<h2 id="寄生构造函数模式">寄生构造函数模式</h2>
<ol>
<li>
<p>基本思想</p>
<ul>
<li>创建一个函数，作用仅仅是封装创建对象的代码</li>
<li>再返回新创建的对象</li>
</ul>
</li>
<li>
<p>示例</p>
<pre><code class="language-javascript">function Person(name, age, job) {
  var o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function() {
    alert(this.name);
  }
  return o;
}
</code></pre>
</li>
</ol>
<h2 id="稳妥构造函数模式">稳妥构造函数模式</h2>
<ol>
<li>
<p>特点：</p>
<ul>
<li>
<p>没有公共属性</p>
</li>
<li>
<p>适合在一些安全的环境中，或者在防止数据被其他应用程序改动时使用</p>
</li>
</ul>
</li>
<li>
<p>示例：</p>
<pre><code class="language-javascript">function Person(name, age, job) {
  var o = new Object();
  o.sayName = function() {
    alert(name);
  }
  return o;
}
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS面向对象-理解对象]]></title>
        <id>https://yuqiusuo.github.io/post/202009141651/</id>
        <link href="https://yuqiusuo.github.io/post/202009141651/">
        </link>
        <updated>2020-09-14T08:50:29.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本篇主要是「JavaScript高级程序设计-面向对象的程序设计」一章中第一篇「理解对象」回顾的笔记</p>
</blockquote>
<h2 id="属性类型">属性类型</h2>
<h3 id="数据属性">数据属性</h3>
<p>数据属性包含一个数据值的位置，在这个位置可以读取和 写入值。它有4个特性：</p>
<ul>
<li><code>[[Configureble]]</code>
<ul>
<li>作用
<ul>
<li>表示能否通过<code>delete</code>删除属性</li>
<li>表示能否修改属性的特性</li>
<li>表示能否把属性修改为访问器属性</li>
</ul>
</li>
<li>默认值
<ul>
<li><code>true</code></li>
</ul>
</li>
</ul>
</li>
<li><code>[[Enumerable]]</code>
<ul>
<li>作用
<ul>
<li>表示能否通过<code>for-in</code>循环返回属性</li>
</ul>
</li>
<li>默认值
<ul>
<li><code>true</code></li>
</ul>
</li>
</ul>
</li>
<li><code>[[Writable]]</code>
<ul>
<li>作用
<ul>
<li>表示能否修改属性的值</li>
</ul>
</li>
<li>默认值
<ul>
<li><code>true</code></li>
</ul>
</li>
</ul>
</li>
<li><code>[[Value]]</code>
<ul>
<li>作用
<ul>
<li>表示能否修改属性的值</li>
</ul>
</li>
<li>默认值
<ul>
<li><code>undefined</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如要修改属性默认的特性，需要使用<strong>ES5</strong>的<code>defineProperty()</code>方法，它接收3个参数：</p>
<ul>
<li>属性所在的对象</li>
<li>属性的名字</li>
<li>一个描述符对象
<ul>
<li>configurable</li>
<li>enumerable</li>
<li>writable</li>
<li>value</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code class="language-javascript">// writable 控制数据是否只读
var person = {};
Object.defineProperty(person, 'name', {
  writable: false,
  value: 'Nicholas'
});
console.log(person.name); // Nicholas
person.name = 'Greg'；
console.log(person.name); // Nicholas

// configurable设置为false后就不能再修改
var person = {};
Object.defineProperty(person, 'name', {
  configurable: false,
  value: 'Nicholas'
});

var person = {};
Object.defineProperty(person, 'name', {
  configurable: true,
  value: 'Nicholas'
}); // 报错
</code></pre>
<h3 id="访问器属性">访问器属性</h3>
<p>访问器属性不包含数据值；它们包含一对<code>getter</code>和<code>setter</code>函数。读取时调用<code>getter</code>，写入时调用<code>setter</code>。访问器属性有4个特性：</p>
<ul>
<li>
<p><code>[[Configureble]]</code></p>
<ul>
<li>作用
<ul>
<li>表示能否通过<code>delete</code>删除属性</li>
<li>表示能否修改属性的特性</li>
<li>表示能否把属性修改为访问器属性</li>
</ul>
</li>
<li>默认值
<ul>
<li><code>true</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>[[Enumerable]]</code></p>
<ul>
<li>作用
<ul>
<li>表示能否通过<code>for-in</code>循环返回属性</li>
</ul>
</li>
<li>默认值
<ul>
<li><code>true</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>[[Set]]</code></p>
<ul>
<li>作用
<ul>
<li>在读取属性时调用的函数</li>
</ul>
</li>
<li>默认值
<ul>
<li>undefined</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>[[Get]]</code></p>
<ul>
<li>作用
<ul>
<li>在写入属性时调用的函数</li>
</ul>
</li>
<li>默认值
<ul>
<li>undefined</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code class="language-javascript">var book = {
  _year: 2004,
  edition: 1
};
Object.defineProperty(book, 'year', {
  get: function() {
    return this._year;
  },
  set: function(newValue) {
    if(newValue &gt; 2004) {
      this._year = newValue;
      this.edition += newValue - 2004;
    }
  }
});

book.year = 2005;
console.log(book.edition); // 12
</code></pre>
<h2 id="定义多个属性">定义多个属性</h2>
<p>可以使用<code>Object.defineProperties</code>。示例：</p>
<pre><code class="language-javascript">var book = {};
Object.defineProperties(book, {
  _year: {
    value: 2004
  },
  edition: {
		value: 1
  },
  year: {
    get: function() {
      return this._year;
    },
    set: function() {
      if(newValue &gt; 2004) {
        this._year = newValue;
        this.edition += newValue - 2004;
      }
    }
  }
});
</code></pre>
<h2 id="读取属性的特性">读取属性的特性</h2>
<p>使用<code>Object.getOwnPropertyDescriptor()</code>，可以取得给制定属性的描述符。</p>
<p>接收参数：</p>
<ul>
<li>属性所在对象</li>
<li>要读取其描述符的属性名称</li>
</ul>
<p>返回值：</p>
<ul>
<li>属性对象</li>
</ul>
<p>示例：</p>
<pre><code class="language-javascript">var book = {};
Object.defineProperties(book, {
  _year: {
    value: 2004
  },
  edition: {
		value: 1
  },
  year: {
    get: function() {
      return this._year;
    },
    set: function() {
      if(newValue &gt; 2004) {
        this._year = newValue;
        this.edition += newValue - 2004;
      }
    }
  }
});

var descriptor = Object.getOwnPropertyDescriptor(book, '_year');
console.log(descriptor.value); // 2004
console.log(descriptor.configurable); // false
console.log(typeof descriptor.get); // undefined

var descriptor = Object.getOwnPropertyDescriptor(book, 'year');
console.log(descriptor.value); // undefined
console.log(descriptor.enumerable); // false
console.log(typeof descriptor.get); // &quot;function&quot;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浏览器的回流(重排)与重绘 ]]></title>
        <id>https://yuqiusuo.github.io/post/liu-lan-qi-de-hui-liu-chong-pai-yu-chong-hui/</id>
        <link href="https://yuqiusuo.github.io/post/liu-lan-qi-de-hui-liu-chong-pai-yu-chong-hui/">
        </link>
        <updated>2020-09-14T08:49:40.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>我们经常说到浏览器的性能问题，其实与浏览器性能息息相关的一点就是浏览器如何渲染我们的网页，这个时候我们就会涉及到一个概念，那就是浏览器的回流(重排，以下统称回流，Reflow)与重绘(Repaint)。</p>
</blockquote>
<h3 id="回流">回流</h3>
<p>对回流这个词，我的理解是<strong>回炉重造</strong>，即对于整个网页重新渲染一遍。那我们可以思考一下，从性能角度来讲，如果我们来写浏览器的代码，一定是再必须要重新渲染网页的时候再重新渲染，那就推出一个问题，什么时候浏览器必须要重新渲染网页？</p>
<p>其实必定是当网页的元素坐标发生变化的时候，这里我们可以理解为有很多人在排队，大家仅仅的依靠在一起，那什么时候大家需要都挪动下位置呢？我觉得要么就是一个人或者几个人突然变胖了/瘦了，那大家如果想要继续依靠在一起，就得都动一动；或者其中一个人或者几个人挪动了一下自己的位置，他势必也会挤着其他人去动一动位置。这种<strong>重新渲染全部或部分文档的动作</strong>我们就叫做<strong>回流</strong>，因为大家都需要挪动下位置，也就导致我们这个网页需要回炉重造了。</p>
<p>所以会导致回流的操作(包括但不限于)：</p>
<ul>
<li>页面首次渲染</li>
<li>浏览器窗口大小发生改变</li>
<li>元素尺寸或位置发生改变</li>
<li>元素内容变化（文字数量或图片大小等等）</li>
<li>元素字体大小变化</li>
<li>添加或者删除<strong>可见</strong>的<code>DOM</code>元素</li>
<li>激活<code>CSS</code>伪类（例如：<code>:hover</code>）</li>
</ul>
<h4 id="重绘">重绘</h4>
<p>还是拿排队举例，当队伍中的一个人需要换一件衣服，比如他从穿黄衣服换成穿红色的衣服，这个时候只要这一个人换件衣服就行了，对其他人并没有影响，这种情况我们就叫做重绘。浏览器只需要对该元素进行重新绘制即可。</p>
<p>所以会导致回流的操作(包括但不限于)：</p>
<ul>
<li>修改color/background-color/visibility</li>
</ul>
<p>由上述可见，其实回流对浏览器性能的消耗是高于重绘的，而且回流的操作一定会伴随着重绘，重绘却不一定伴随回流。那现代浏览器其实对这块是有进行优化处理的，如果我们的队伍总是需要变换位置，我们就统一来一次大排队。</p>
<p>那么我们在平时的工作中，如果针对于回流和重绘写出性能更好地代码呢？有以下几点可以注意的：</p>
<h5 id="css">CSS</h5>
<ul>
<li>避免使用<code>table</code>布局。</li>
<li>尽可能在<code>DOM</code>树的最末端改变<code>class</code>。</li>
<li>避免设置多层内联样式。</li>
<li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上。</li>
<li>避免使用<code>CSS</code>表达式（例如：<code>calc()</code>）。</li>
</ul>
<h5 id="javascript">JavaScript</h5>
<ul>
<li>避免频繁操作样式，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</li>
<li>避免频繁操作<code>DOM</code>，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM操作</code>，最后再把它添加到文档中。</li>
<li>也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在<code>display</code>属性为<code>none</code>的元素上进行的<code>DOM</code>操作不会引发回流和重绘。</li>
<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>
<p>参考 <a href="https://juejin.im/post/5a9923e9518825558251c96a">浏览器的回流与重绘 (Reflow &amp; Repaint)</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[谈前端权限]]></title>
        <id>https://yuqiusuo.github.io/post/202009141649/</id>
        <link href="https://yuqiusuo.github.io/post/202009141649/">
        </link>
        <updated>2020-09-14T08:48:46.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>自从有了前后端分离，前端的工作内容就变得越发多起来，其中有一项就是权限控制，下面就谈一谈前端权限。</p>
</blockquote>
<h4 id="what">WHAT</h4>
<p>首先我们要理清前端权限是什么，我理解的前端权限就是<strong>控制前端元素是否可见</strong>。因为之前后台模板时代，我们的页面都是通过后台来渲染的，能不能访问到页面直接由后台逻辑判断就好。但是现在我们到了前后端分离时代，所有页面的元素都由页面本身来控制，所以页面路由这块需要由前端本身来控制了。所以我认为前端权限有这几个关键点：</p>
<ul>
<li>前端权限是基于前后端分离之上的</li>
<li>前端只能做视觉上的控制</li>
<li>权限控制不能放在前端，后台还是需要对每一个接口做验权</li>
</ul>
<h4 id="why">WHY</h4>
<p>下面我们说一说为什么说<strong>前端只能做视觉上的控制</strong>和<strong>权限控制不能放在前端，后台还是需要对每一个接口做验权</strong>。我觉得其实WEB本身就是围绕数据来的，所以我们前端安全，主要是保护我们的<strong>数据</strong>，那和数据最紧密接触的其实还是后台，前端本身做得是<strong>数据的展示和收集</strong>，但是数据的存储和处理并不是由前端来做。所以即使前端能控制住路由/按钮等不被别人看到，发送请求的方式还是有很多，完全可以绕过前端来请求数据。所以从某种意义上来说，就算前端的权限控制做得再严密，可能作用也是有限的。这也引申了后面一句，后台还是要对每一个接口做验权。</p>
<h4 id="how">HOW</h4>
<p>但是前端做权限控制还是非常有意义的，我觉得在安全性方面来说，前端就显示人体的皮肤，我们会是WEB安全的第一道防线。前端要做的工作，我认为有三种：</p>
<ul>
<li>前端路由展示</li>
<li>前端按钮级别展示</li>
<li>调用接口与后台配合</li>
</ul>
<ol>
<li>
<p>首先，我们所以说前端路由展示。这里其实可以分为两种方式来做路由权限控制：</p>
<ul>
<li>前端保存所有路由，通过请求获取权限列表，然后由前端筛选出来可访问路由进行展示</li>
<li>前端仅保存文件关系，由后台根据user信息生成路由，通过请求传递到前端渲染</li>
</ul>
<p>第一种方法比较方便，后一种更灵活，比如我们的页面需要通过后台配置访问，就可以通过第二种方法来实现。</p>
</li>
<li>
<p>按钮级别的展示（Vue示例）</p>
<ul>
<li>先通过请求获取到按钮级别的权限列表</li>
<li>封装一个公用的筛选方法，再通过v-if调用该方法确定是否渲染 <strong>OR</strong> 封装一个指令（directive）来控制按钮是否渲染</li>
</ul>
</li>
<li>
<p>调用接口与后台配合</p>
<p>其实我们最主要的与后台沟通的方式还是通过调用接口，与后台进行数据交流，但是如上所说，后台还是需要对每一个接口进行鉴权。前后端配合主要有以下几种方式：</p>
<ul>
<li>HTTP Basic Authentication</li>
<li>session-Cookie   <strong>常用</strong></li>
<li>Token-Cookie    <strong>常用</strong></li>
<li>OAuth(开放授权) -- QQ授权登陆常用</li>
</ul>
<p>已上几种方法，大家可以很轻松google到相关信息，本篇就不赘述了。已上就是我理解的前端权限~</p>
</li>
</ol>
]]></content>
    </entry>
</feed>